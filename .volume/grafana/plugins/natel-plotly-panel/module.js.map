{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"lodash\"","webpack:///./module.ts","webpack:///./SeriesWrapper.ts","webpack:///./editor.ts","webpack:///./libLoader.ts","webpack:///../node_modules/scriptjs/dist/script.js","webpack:///./anno.ts"],"names":["installedModules","__webpack_require__","m","module","exports","__WEBPACK_EXTERNAL_MODULE__0__","Plotly","styleSheets","ruleIdx","rule","r","this","onInitEditMode","addEditorTab","cfg","layout","old","indexOf","trace","xaxis","yaxis","scaleanchor","zaxis","mapping","labelStyle","font","gridcolor","color","onRender","t","data","i","Number","points","found","Math","ts","l","onDataReceived","finfo","push","SeriesWrapperSeries","refId","series","s","hchanged","editor","_updateTracesFromConfigs","traces","marker","__addCopyPath","_updateTraceData","force","__set","error","vals","onConfigChanged","link","e","a","obj","events","on","PlotlyPanelCtrl","type","getKey","getAllKeys","SeriesWrapper","toArray","c","EditorHelper","ctrl","changed","o","axis","label","property","segment","updateSegMapping","opts","value","resolve","console","log","loaded","loadPlotly","$script","x","y","d","name","getter","Object","defineProperty","enumerable","get","Symbol","toStringTag","mode","__esModule","ns","create","key","bind","n","object","prototype","hasOwnProperty","call","p","moduleId","modules"],"mappings":"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","file":"module.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","/* -*- Mode: typescript; indent-tabs-mode: nil; typescript-indent-level: 2 -*- */\n\n///<reference path=\"../node_modules/grafana-sdk-mocks/app/headers/common.d.ts\" />\n\nimport {MetricsPanelCtrl} from 'app/plugins/sdk';\n\nimport _ from 'lodash';\nimport moment from 'moment';\nimport $ from 'jquery';\n\nimport {\n  SeriesWrapper,\n  SeriesWrapperSeries,\n  SeriesWrapperTable,\n  SeriesWrapperTableRow,\n} from './SeriesWrapper';\nimport {EditorHelper} from './editor';\n\nimport {loadPlotly, loadIfNecessary} from './libLoader';\nimport {AnnoInfo} from './anno';\nimport {Axis} from 'plotly.js';\n\nlet Plotly: any; // Loaded dynamically!\n\nclass PlotlyPanelCtrl extends MetricsPanelCtrl {\n  static templateUrl = 'partials/module.html';\n  static configVersion = 1; // An index to help config migration\n\n  initialized: boolean;\n  //$tooltip: any;\n\n  static defaultTrace = {\n    mapping: {\n      x: null,\n      y: null,\n      z: null,\n      text: null,\n      color: null,\n      size: null,\n    },\n    show: {\n      line: true,\n      markers: true,\n    },\n    settings: {\n      line: {\n        color: '#005f81',\n        width: 6,\n        dash: 'solid',\n        shape: 'linear',\n      },\n      marker: {\n        size: 15,\n        symbol: 'circle',\n        color: '#33B5E5',\n        colorscale: 'YlOrRd',\n        sizemode: 'diameter',\n        sizemin: 3,\n        sizeref: 0.2,\n        line: {\n          color: '#DDD',\n          width: 0,\n        },\n        showscale: false,\n      },\n      color_option: 'ramp',\n    },\n  };\n\n  static yaxis2: Partial<Axis> = {\n    title: 'Annotations',\n    type: 'linear',\n    range: [0, 1],\n    visible: false,\n  };\n\n  static defaults = {\n    pconfig: {\n      loadFromCDN: false,\n      showAnnotations: true,\n      fixScale: '',\n      traces: [PlotlyPanelCtrl.defaultTrace],\n      settings: {\n        type: 'scatter',\n        displayModeBar: false,\n      },\n      layout: {\n        showlegend: false,\n        legend: {\n          orientation: 'h',\n        },\n        dragmode: 'lasso', // (enumerated: \"zoom\" | \"pan\" | \"select\" | \"lasso\" | \"orbit\" | \"turntable\" )\n        hovermode: 'closest',\n        font: {\n          family: '\"Open Sans\", Helvetica, Arial, sans-serif',\n        },\n        xaxis: {\n          showgrid: true,\n          zeroline: false,\n          type: 'auto',\n          rangemode: 'normal', // (enumerated: \"normal\" | \"tozero\" | \"nonnegative\" )\n        },\n        yaxis: {\n          showgrid: true,\n          zeroline: false,\n          type: 'linear',\n          rangemode: 'normal', // (enumerated: \"normal\" | \"tozero\" | \"nonnegative\" ),\n        },\n        zaxis: {\n          showgrid: true,\n          zeroline: false,\n          type: 'linear',\n          rangemode: 'normal', // (enumerated: \"normal\" | \"tozero\" | \"nonnegative\" )\n        },\n      },\n    },\n  };\n\n  graphDiv: any;\n  annotations = new AnnoInfo();\n  series: SeriesWrapper[];\n  seriesByKey: Map<string, SeriesWrapper> = new Map();\n  seriesHash = '?';\n\n  traces: any[]; // The data sent directly to Plotly -- with a special __copy element\n  layout: any; // The layout used by Plotly\n\n  mouse: any;\n  cfg: any;\n\n  // For editor\n  editor: EditorHelper;\n  dataWarnings: string[]; // warnings about loading data\n\n  /** @ngInject **/\n  constructor(\n    $scope,\n    $injector,\n    $window,\n    private $rootScope,\n    public uiSegmentSrv,\n    private annotationsSrv\n  ) {\n    super($scope, $injector);\n\n    this.initialized = false;\n\n    //this.$tooltip = $('<div id=\"tooltip\" class=\"graph-tooltip\">');\n\n    // defaults configs\n    _.defaultsDeep(this.panel, PlotlyPanelCtrl.defaults);\n\n    this.cfg = this.panel.pconfig;\n\n    this.traces = [];\n\n    // ?? This seems needed for tests?!!\n    if (!this.events) {\n      return;\n    }\n\n    loadPlotly(this.cfg).then(v => {\n      Plotly = v;\n      console.log('Plotly', v);\n\n      // Wait till plotly exists has loaded before we handle any data\n      this.events.on('render', this.onRender.bind(this));\n      this.events.on('data-received', this.onDataReceived.bind(this));\n      this.events.on('data-error', this.onDataError.bind(this));\n      this.events.on('panel-size-changed', this.onResize.bind(this));\n      this.events.on('data-snapshot-load', this.onDataSnapshotLoad.bind(this));\n      this.events.on('refresh', this.onRefresh.bind(this));\n\n      // Refresh after plotly is loaded\n      this.refresh();\n    });\n\n    // Standard handlers\n    this.events.on('init-edit-mode', this.onInitEditMode.bind(this));\n    this.events.on('panel-initialized', this.onPanelInitialized.bind(this));\n  }\n\n  getCssRule(selectorText): CSSStyleRule | null {\n    const styleSheets = document.styleSheets;\n    for (let idx = 0; idx < styleSheets.length; idx += 1) {\n      const styleSheet = styleSheets[idx] as CSSStyleSheet;\n      const rules = styleSheet.cssRules;\n      for (let ruleIdx = 0; ruleIdx < rules.length; ruleIdx += 1) {\n        const rule = rules[ruleIdx] as CSSStyleRule;\n        if (rule.selectorText === selectorText) {\n          return rule;\n        }\n      }\n    }\n    return null;\n  }\n\n  // Don't call resize too quickly\n  doResize = _.debounce(() => {\n    // https://github.com/alonho/angular-plotly/issues/26\n    const e = window.getComputedStyle(this.graphDiv).display;\n    if (!e || 'none' === e) {\n      // not drawn!\n      console.warn('resize a plot that is not drawn yet');\n    } else {\n      const rect = this.graphDiv.getBoundingClientRect();\n      this.layout.width = rect.width;\n      this.layout.height = this.height;\n      Plotly.redraw(this.graphDiv);\n    }\n  }, 50);\n\n  onResize() {\n    if (this.graphDiv && this.layout && Plotly) {\n      this.doResize(); // Debounced\n    }\n  }\n\n  onDataError(err) {\n    this.series = [];\n    this.annotations.clear();\n    this.render();\n  }\n\n  onRefresh() {\n    // ignore fetching data if another panel is in fullscreen\n    if (this.otherPanelInFullscreenMode()) {\n      return;\n    }\n\n    if (this.graphDiv && this.initialized && Plotly) {\n      Plotly.redraw(this.graphDiv);\n    }\n  }\n\n  onInitEditMode() {\n    this.editor = new EditorHelper(this);\n    this.addEditorTab('Display', 'public/plugins/natel-plotly-panel/partials/tab_display.html', 2);\n    this.addEditorTab('Traces', 'public/plugins/natel-plotly-panel/partials/tab_traces.html', 3);\n    //  this.editorTabIndex = 1;\n    this.onConfigChanged(); // Sets up the axis info\n\n    // Check the size in a little bit\n    setTimeout(() => {\n      console.log('RESIZE in editor');\n      this.onResize();\n    }, 500);\n  }\n\n  processConfigMigration() {\n    console.log('Migrating Plotly Configuration to version: ' + PlotlyPanelCtrl.configVersion);\n\n    // Remove some things that should not be saved\n    const cfg = this.panel.pconfig;\n    delete cfg.layout.plot_bgcolor;\n    delete cfg.layout.paper_bgcolor;\n    delete cfg.layout.autosize;\n    delete cfg.layout.height;\n    delete cfg.layout.width;\n    delete cfg.layout.margin;\n    delete cfg.layout.scene;\n    if (!this.is3d()) {\n      delete cfg.layout.zaxis;\n    }\n\n    // Move from 'markers-lines' to checkbox\n    if (cfg.settings.mode) {\n      const old = cfg.settings.mode;\n      const show = {\n        markers: old.indexOf('markers') >= 0,\n        lines: old.indexOf('lines') >= 0,\n      };\n      _.forEach(cfg.traces, trace => {\n        trace.show = show;\n      });\n      delete cfg.settings.mode;\n    }\n\n    // TODO... MORE Migrations\n    console.log('After Migration:', cfg);\n    this.cfg = cfg;\n    this.panel.version = PlotlyPanelCtrl.configVersion;\n  }\n\n  onPanelInitialized() {\n    if (!this.panel.version || PlotlyPanelCtrl.configVersion > this.panel.version) {\n      this.processConfigMigration();\n    }\n    this._updateTraceData(true);\n  }\n\n  deepCopyWithTemplates = obj => {\n    if (_.isArray(obj)) {\n      return obj.map(val => this.deepCopyWithTemplates(val));\n    } else if (_.isString(obj)) {\n      return this.templateSrv.replace(obj, this.panel.scopedVars);\n    } else if (_.isObject(obj)) {\n      const copy = {};\n      _.forEach(obj, (v, k) => {\n        copy[k] = this.deepCopyWithTemplates(v);\n      });\n      return copy;\n    }\n    return obj;\n  };\n\n  getProcessedLayout() {\n    // Copy from config\n    const layout = this.deepCopyWithTemplates(this.cfg.layout);\n    layout.plot_bgcolor = 'transparent';\n    layout.paper_bgcolor = layout.plot_bgcolor;\n\n    // Update the size\n    const rect = this.graphDiv.getBoundingClientRect();\n    layout.autosize = false; // height is from the div\n    layout.height = this.height;\n    layout.width = rect.width;\n\n    // Make sure it is something\n    if (!layout.xaxis) {\n      layout.xaxis = {};\n    }\n    if (!layout.yaxis) {\n      layout.yaxis = {};\n    }\n\n    // Fixed scales\n    if (this.cfg.fixScale) {\n      if ('x' === this.cfg.fixScale) {\n        layout.yaxis.scaleanchor = 'x';\n      } else if ('y' === this.cfg.fixScale) {\n        layout.xaxis.scaleanchor = 'y';\n      } else if ('z' === this.cfg.fixScale) {\n        layout.xaxis.scaleanchor = 'z';\n        layout.yaxis.scaleanchor = 'z';\n      }\n    }\n\n    if (this.is3d()) {\n      if (!layout.zaxis) {\n        layout.zaxis = {};\n      }\n\n      // 3d uses 'scene' for the axis\n      layout.scene = {\n        xaxis: layout.xaxis,\n        yaxis: layout.yaxis,\n        zaxis: layout.zaxis,\n      };\n\n      delete layout.xaxis;\n      delete layout.yaxis;\n      delete layout.zaxis;\n\n      layout.margin = {\n        l: 0,\n        r: 0,\n        t: 0,\n        b: 5,\n        pad: 0,\n      };\n    } else {\n      delete layout.zaxis;\n      delete layout.scene;\n\n      // Check if the X axis should be a date\n      if (!layout.xaxis.type || layout.xaxis.type === 'auto') {\n        const mapping = _.get(this.cfg, 'traces[0].mapping.x');\n        if (mapping && mapping.indexOf('time') >= 0) {\n          layout.xaxis.type = 'date';\n        }\n      }\n\n      const isDate = layout.xaxis.type === 'date';\n      layout.margin = {\n        l: layout.yaxis.title ? 50 : 35,\n        r: 5,\n        t: 0,\n        b: layout.xaxis.title ? 65 : isDate ? 40 : 30,\n        pad: 2,\n      };\n\n      // Set the range to the query window\n      if (isDate && !layout.xaxis.range) {\n        const range = this.timeSrv.timeRange();\n        layout.xaxis.range = [range.from.valueOf(), range.to.valueOf()];\n      }\n\n      // get the css rule of grafana graph axis text\n      const labelStyle = this.getCssRule('div.flot-text');\n      if (labelStyle) {\n        let color = labelStyle.style.color;\n        if (!layout.font) {\n          layout.font = {};\n        }\n        layout.font.color = color;\n\n        // make the grid a little more transparent\n        color = $.color\n          .parse(color)\n          .scale('a', 0.22)\n          .toString();\n\n        // set gridcolor (like grafana graph)\n        layout.xaxis.gridcolor = color;\n        layout.yaxis.gridcolor = color;\n      }\n\n      // Set the second axis\n      layout.yaxis2 = PlotlyPanelCtrl.yaxis2;\n    }\n    return layout;\n  }\n\n  onRender() {\n    // ignore fetching data if another panel is in fullscreen\n    if (this.otherPanelInFullscreenMode() || !this.graphDiv) {\n      return;\n    }\n\n    if (!Plotly) {\n      return;\n    }\n\n    if (!this.initialized) {\n      const s = this.cfg.settings;\n\n      const options = {\n        showLink: false,\n        displaylogo: false,\n        displayModeBar: s.displayModeBar,\n        modeBarButtonsToRemove: ['sendDataToCloud'], //, 'select2d', 'lasso2d']\n      };\n\n      this.layout = this.getProcessedLayout();\n      this.layout.shapes = this.annotations.shapes;\n      let traces = this.traces;\n      if (this.annotations.shapes.length > 0) {\n        traces = this.traces.concat(this.annotations.trace);\n      }\n      Plotly.react(this.graphDiv, traces, this.layout, options);\n\n      this.graphDiv.on('plotly_click', data => {\n        if (data === undefined || data.points === undefined) {\n          return;\n        }\n        for (let i = 0; i < data.points.length; i++) {\n          const idx = data.points[i].pointNumber;\n          const ts = this.traces[0].ts[idx];\n          // console.log( 'CLICK!!!', ts, data );\n          const msg = data.points[i].x.toPrecision(4) + ', ' + data.points[i].y.toPrecision(4);\n          this.$rootScope.appEvent('alert-success', [\n            msg,\n            '@ ' + this.dashboard.formatDate(moment(ts)),\n          ]);\n        }\n      });\n\n      // if(true) {\n      //   this.graphDiv.on('plotly_hover', (data, xxx) => {\n      //     console.log( 'HOVER!!!', data, xxx, this.mouse );\n      //     if(data.points.length>0) {\n      //       var idx = 0;\n      //       var pt = data.points[idx];\n\n      //       var body = '<div class=\"graph-tooltip-time\">'+ pt.pointNumber +'</div>';\n      //       body += \"<center>\";\n      //       body += pt.x + ', '+pt.y;\n      //       body += \"</center>\";\n\n      //       //this.$tooltip.html( body ).place_tt( this.mouse.pageX + 10, this.mouse.pageY );\n      //     }\n      //   }).on('plotly_unhover', (data) => {\n      //     //this.$tooltip.detach();\n      //   });\n      // }\n\n      this.graphDiv.on('plotly_selected', data => {\n        if (data === undefined || data.points === undefined) {\n          return;\n        }\n\n        if (data.points.length === 0) {\n          console.log('Nothing Selected', data);\n          return;\n        }\n\n        console.log('SELECTED', data);\n\n        let min = Number.MAX_SAFE_INTEGER;\n        let max = Number.MIN_SAFE_INTEGER;\n\n        for (let i = 0; i < data.points.length; i++) {\n          const found = data.points[i];\n          const idx = found.pointNumber;\n          const ts = found.fullData.x[idx];\n          min = Math.min(min, ts);\n          max = Math.max(max, ts);\n        }\n\n        // At least 2 seconds\n        min -= 1000;\n        max += 1000;\n\n        const range = {from: moment.utc(min), to: moment.utc(max)};\n\n        console.log('SELECTED!!!', min, max, data.points.length, range);\n\n        this.timeSrv.setTime(range);\n\n        // rebuild the graph after query\n        if (this.graphDiv) {\n          Plotly.Plots.purge(this.graphDiv);\n          this.graphDiv.innerHTML = '';\n          this.initialized = false;\n        }\n      });\n      this.initialized = true;\n    } else if (this.initialized) {\n      Plotly.redraw(this.graphDiv).then(() => {\n        this.renderingCompleted();\n      });\n    } else {\n      console.log('Not initialized yet!');\n    }\n  }\n\n  onDataSnapshotLoad(snapshot) {\n    this.onDataReceived(snapshot);\n  }\n\n  _hadAnno = false;\n\n  onDataReceived(dataList) {\n    const finfo: SeriesWrapper[] = [];\n    let seriesHash = '/';\n    if (dataList && dataList.length > 0) {\n      const useRefID = dataList.length === this.panel.targets.length;\n      dataList.forEach((series, sidx) => {\n        let refId = '';\n        if (useRefID) {\n          refId = _.get(this.panel, 'targets[' + sidx + '].refId');\n          if (!refId) {\n            refId = String.fromCharCode('A'.charCodeAt(0) + sidx);\n          }\n        }\n        if (series.columns) {\n          for (let i = 0; i < series.columns.length; i++) {\n            finfo.push(new SeriesWrapperTable(refId, series, i));\n          }\n          finfo.push(new SeriesWrapperTableRow(refId, series));\n        } else if (series.target) {\n          finfo.push(new SeriesWrapperSeries(refId, series, 'value'));\n          finfo.push(new SeriesWrapperSeries(refId, series, 'time'));\n          finfo.push(new SeriesWrapperSeries(refId, series, 'index'));\n        } else {\n          console.error('Unsupported Series response', sidx, series);\n        }\n      });\n    }\n    this.seriesByKey.clear();\n    finfo.forEach(s => {\n      s.getAllKeys().forEach(k => {\n        this.seriesByKey.set(k, s);\n        seriesHash += '$' + k;\n      });\n    });\n    this.series = finfo;\n\n    // Now Process the loaded data\n    const hchanged = this.seriesHash !== seriesHash;\n    if (hchanged && this.editor) {\n      EditorHelper.updateMappings(this);\n      this.editor.selectTrace(this.editor.traceIndex);\n      this.editor.onConfigChanged();\n    }\n\n    if (hchanged || !this.initialized) {\n      this.onConfigChanged();\n      this.seriesHash = seriesHash;\n    }\n\n    // Support Annotations\n    let annotationPromise = Promise.resolve();\n    if (!this.cfg.showAnnotations || this.is3d()) {\n      this.annotations.clear();\n      if (this.layout) {\n        if (this.layout.shapes) {\n          this.onConfigChanged();\n        }\n        this.layout.shapes = [];\n      }\n    } else {\n      annotationPromise = this.annotationsSrv\n        .getAnnotations({\n          dashboard: this.dashboard,\n          panel: this.panel,\n          range: this.range,\n        })\n        .then(results => {\n          const hasAnno = this.annotations.update(results);\n          if (this.layout) {\n            if (hasAnno !== this._hadAnno) {\n              this.onConfigChanged();\n            }\n            this.layout.shapes = this.annotations.shapes;\n          }\n          this._hadAnno = hasAnno;\n        });\n    }\n\n    // Load the real data changes\n    annotationPromise.then(() => {\n      this._updateTraceData();\n      this.render();\n    });\n  }\n\n  __addCopyPath(trace: any, key: string, path: string) {\n    if (key) {\n      trace.__set.push({\n        key: key,\n        path: path,\n      });\n      const s: SeriesWrapper = this.seriesByKey.get(key);\n      if (!s) {\n        this.dataWarnings.push('Unable to find: ' + key + ' for ' + trace.name + ' // ' + path);\n      }\n    }\n  }\n\n  // This will update all trace settings *except* the data\n  _updateTracesFromConfigs() {\n    this.dataWarnings = [];\n\n    // Make sure we have a trace\n    if (this.cfg.traces == null || this.cfg.traces.length < 1) {\n      this.cfg.traces = [_.cloneDeep(PlotlyPanelCtrl.defaultTrace)];\n    }\n\n    const is3D = this.is3d();\n    this.traces = this.cfg.traces.map((tconfig, idx) => {\n      const config = this.deepCopyWithTemplates(tconfig) || {};\n      _.defaults(config, PlotlyPanelCtrl.defaults);\n      const mapping = config.mapping;\n\n      const trace: any = {\n        name: config.name || EditorHelper.createTraceName(idx),\n        type: this.cfg.settings.type,\n        mode: 'markers+lines', // really depends on config settings\n        __set: [], // { key:? property:? }\n      };\n\n      let mode = '';\n      if (config.show.markers) {\n        mode += '+markers';\n        trace.marker = config.settings.marker;\n\n        delete trace.marker.sizemin;\n        delete trace.marker.sizemode;\n        delete trace.marker.sizeref;\n\n        if (config.settings.color_option === 'ramp') {\n          this.__addCopyPath(trace, mapping.color, 'marker.color');\n        } else {\n          delete trace.marker.colorscale;\n          delete trace.marker.showscale;\n        }\n      }\n\n      if (config.show.lines) {\n        mode += '+lines';\n        trace.line = config.settings.line;\n      }\n\n      // Set the text\n      this.__addCopyPath(trace, mapping.text, 'text');\n      this.__addCopyPath(trace, mapping.x, 'x');\n      this.__addCopyPath(trace, mapping.y, 'y');\n\n      if (is3D) {\n        this.__addCopyPath(trace, mapping.z, 'z');\n      }\n\n      // Set the trace mode\n      if (mode) {\n        trace.mode = mode.substring(1);\n      }\n      return trace;\n    });\n  }\n\n  // Fills in the required data into the trace values\n  _updateTraceData(force = false): boolean {\n    if (!this.series) {\n      // console.log('NO Series data yet!');\n      return false;\n    }\n\n    if (force || !this.traces) {\n      this._updateTracesFromConfigs();\n    } else if (this.traces.length !== this.cfg.traces.length) {\n      console.log(\n        'trace number mismatch.  Found: ' +\n          this.traces.length +\n          ', expect: ' +\n          this.cfg.traces.length\n      );\n      this._updateTracesFromConfigs();\n    }\n\n    // Use zero when the metric value is missing\n    // Plotly gets lots of errors when the values are missing\n    let zero: any = [];\n    this.traces.forEach(trace => {\n      if (trace.__set) {\n        trace.__set.forEach(v => {\n          const s = this.seriesByKey.get(v.key);\n          let vals: any[] = zero;\n          if (s) {\n            vals = s.toArray();\n            if (vals && vals.length > zero.length) {\n              zero = Array.from(Array(3), () => 0);\n            }\n          } else {\n            if (!this.error) {\n              this.error = '';\n            }\n            this.error += 'Unable to find: ' + v.key + ' (using zeros).  ';\n          }\n          if (!vals) {\n            vals = zero;\n          }\n          _.set(trace, v.path, vals);\n        });\n      }\n    });\n\n    //console.log('SetDATA', this.traces);\n    return true;\n  }\n\n  onConfigChanged() {\n    // Force reloading the traces\n    this._updateTraceData(true);\n\n    if (!Plotly) {\n      return;\n    }\n\n    // Check if the plotly library changed\n    loadIfNecessary(this.cfg).then(res => {\n      if (res) {\n        if (Plotly) {\n          Plotly.purge(this.graphDiv);\n        }\n        Plotly = res;\n      }\n\n      // Updates the layout and redraw\n      if (this.initialized && this.graphDiv) {\n        if (!this.cfg.showAnnotations) {\n          this.annotations.clear();\n        }\n\n        const s = this.cfg.settings;\n        const options = {\n          showLink: false,\n          displaylogo: false,\n          displayModeBar: s.displayModeBar,\n          modeBarButtonsToRemove: ['sendDataToCloud'], //, 'select2d', 'lasso2d']\n        };\n        this.layout = this.getProcessedLayout();\n        this.layout.shapes = this.annotations.shapes;\n        let traces = this.traces;\n        if (this.annotations.shapes.length > 0) {\n          traces = this.traces.concat(this.annotations.trace);\n        }\n        console.log('ConfigChanged (traces)', traces);\n        Plotly.react(this.graphDiv, traces, this.layout, options);\n      }\n\n      this.render(); // does not query again!\n    });\n  }\n\n  is3d() {\n    return this.cfg.settings.type === 'scatter3d';\n  }\n\n  link(scope, elem, attrs, ctrl) {\n    this.graphDiv = elem.find('.plotly-spot')[0];\n    this.initialized = false;\n    elem.on('mousemove', evt => {\n      this.mouse = evt;\n    });\n\n    //let p = $(this.graphDiv).parent().parent()[0];\n    //console.log( 'PLOT', this.graphDiv, p );\n  }\n}\n\nexport {PlotlyPanelCtrl, PlotlyPanelCtrl as PanelCtrl};\n","import _ from 'lodash';\n\n// This gives a standard way to get a value for a given field\nexport abstract class SeriesWrapper {\n  refId: string; // From Query Target\n  name: string;\n\n  type?: 'string' | 'date' | 'boolean' | 'epoch' | 'number';\n  first?: any;\n  count: number;\n\n  /** @ngInject */\n  constructor(refId: string) {\n    this.refId = refId;\n  }\n\n  protected setFirst(v: any) {\n    this.first = v;\n    if (_.isNumber(v)) {\n      this.type = 'number';\n    } else if (_.isString(v)) {\n      this.type = 'string';\n    } else if (typeof v === typeof true) {\n      this.type = 'boolean';\n    }\n  }\n\n  // The best key for this field\n  getKey(): string {\n    return this.name;\n  }\n\n  // All ways to access this field\n  getAllKeys(): string[] {\n    return [this.getKey()];\n  }\n\n  abstract toArray(): Array<string | number | boolean>;\n}\n\nexport class SeriesWrapperSeries extends SeriesWrapper {\n  value: 'value' | 'index' | 'time';\n\n  /** @ngInject */\n  constructor(refId: string, public series: any, val: 'value' | 'index' | 'time') {\n    super(refId);\n    this.value = val;\n    this.count = series.datapoints.length;\n    this.name = series.target;\n\n    if ('index' === val) {\n      this.first = 0;\n      this.type = 'number';\n      this.name += '@index';\n      return;\n    }\n    if ('value' === val) {\n      _.forEach(series.datapoints, arr => {\n        if (arr[0] !== null) {\n          // 0 is an ok value so cant use if(arr[0])\n          this.setFirst(arr[0]);\n          return false;\n        }\n        return true; // continue\n      });\n      return;\n    }\n    if ('time' === val) {\n      this.type = 'epoch';\n      this.first = series.datapoints[0][1];\n      this.name += '@time';\n      return;\n    }\n  }\n\n  toArray(): any[] {\n    if ('index' === this.value) {\n      const arr = new Array(this.count);\n      for (let i = 0; i < this.count; i++) {\n        arr[i] = i;\n      }\n      return arr;\n    }\n    const idx = 'time' === this.value ? 1 : 0;\n    return _.map(this.series.datapoints, arr => {\n      return arr[idx];\n    });\n  }\n\n  getAllKeys(): string[] {\n    if (this.refId) {\n      const vals = [this.name, this.refId + '@' + this.value, this.refId + '/' + this.name];\n\n      if ('A' === this.refId) {\n        vals.push('@' + this.value);\n      }\n      return vals;\n    }\n    return [this.name];\n  }\n}\n\nexport class SeriesWrapperTableRow extends SeriesWrapper {\n  /** @ngInject */\n  constructor(refId: string, public table: any) {\n    super(refId);\n\n    this.name = refId + '@row';\n  }\n\n  toArray(): any[] {\n    const count = this.table.rows.length;\n    const arr = new Array(count);\n    for (let i = 0; i < count; i++) {\n      arr[i] = i;\n    }\n    return arr;\n  }\n}\n\nexport class SeriesWrapperTable extends SeriesWrapper {\n  /** @ngInject */\n  constructor(refId: string, public table: any, public index: number) {\n    super(refId);\n    this.count = table.rows.length;\n\n    const col = table.columns[index];\n    if (!col) {\n      throw new Error('Unkonwn Column: ' + index);\n    }\n\n    this.name = col.text;\n    if ('time' === col.type) {\n      this.type = 'epoch';\n      this.first = table.rows[0][index];\n    } else {\n      for (let i = 0; i < this.count; i++) {\n        const v = table.rows[i][index];\n        if (v !== null) {\n          // 0 is an ok value so cant use if(v)\n          this.setFirst(v);\n          return;\n        }\n      }\n    }\n  }\n\n  toArray(): any[] {\n    return _.map(this.table.rows, row => {\n      return row[this.index];\n    });\n  }\n\n  getAllKeys(): string[] {\n    if (this.refId) {\n      return [this.getKey(), this.refId + '/' + this.name, this.refId + '[' + this.index + ']'];\n    }\n    return [this.getKey()];\n  }\n}\n","import _ from 'lodash';\n\nimport {PlotlyPanelCtrl} from './module';\n\nclass AxisInfo {\n  label: string;\n  layout: any; // The config saved in layout\n  property: string; // mapping property to check in a trace\n  segment: any; // The Grafana <metric-segment\n}\n\nconst REMOVE_KEY = '-- remove --';\n\nexport class EditorHelper {\n  axis = new Array<AxisInfo>();\n  trace: any; // Trace Config\n  traceIndex = 0;\n  traces: any[]; // array of configs;\n\n  symbol: any; // The Grafana <metric-segment for this symbol\n  mapping: any = {}; // The Grafana <metric-segment for this symbol\n\n  /** @ngInject */\n  constructor(public ctrl: PlotlyPanelCtrl) {\n    EditorHelper.updateMappings(ctrl);\n    this.selectTrace(0);\n  }\n\n  // Callback when the query results changed\n  static updateMappings(ctrl: PlotlyPanelCtrl): boolean {\n    if (ctrl.series == null || ctrl.series.length < 1) {\n      return false;\n    }\n\n    const defaultMappings = {\n      first: ctrl.series[0].getKey(),\n      time: ctrl.series[1].getKey(),\n    };\n\n    let changed = false;\n    ctrl.cfg.traces.forEach(trace => {\n      _.defaults(trace, PlotlyPanelCtrl.defaultTrace);\n      const mapping = trace.mapping;\n      if (!mapping.color) {\n        mapping.color = defaultMappings.first;\n        changed = true;\n      }\n      if (!mapping.x) {\n        mapping.x = defaultMappings.time;\n        changed = true;\n      }\n      if (!mapping.y) {\n        mapping.y = defaultMappings.first;\n        changed = true;\n      }\n      if (ctrl.is3d() && !mapping.z) {\n        mapping.z = defaultMappings.first;\n        changed = true;\n      }\n    });\n    return changed;\n  }\n\n  onConfigChanged() {\n    this.onUpdateAxis(); // Every time????\n\n    // Initalize the axis\n    for (let i = 0; i < this.axis.length; i++) {\n      if (this.axis[i].layout.rangemode === 'between') {\n        if (!_.isArray(this.axis[i].layout.range)) {\n          this.axis[i].layout.range = [0, null];\n        }\n      } else {\n        delete this.axis[i].layout.range;\n      }\n    }\n\n    this.ctrl.onConfigChanged();\n  }\n\n  onUpdateAxis() {\n    const mapping = this.trace.mapping;\n    if (!mapping) {\n      console.error('Missing mappings for trace', this.trace);\n      return;\n    }\n\n    const layout = this.ctrl.cfg.layout;\n    if (!layout.xaxis) {\n      layout.xaxis = {};\n    }\n    if (!layout.yaxis) {\n      layout.yaxis = {};\n    }\n\n    this.axis = [];\n    this.axis.push({\n      label: 'X Axis',\n      layout: layout.xaxis,\n      property: 'x',\n      segment: this.mapping.x,\n    });\n    this.axis.push({\n      label: 'Y Axis',\n      layout: layout.yaxis,\n      property: 'y',\n      segment: this.mapping.y,\n    });\n\n    if (this.ctrl.is3d()) {\n      if (!layout.zaxis) {\n        layout.zaxis = {};\n      }\n      this.axis.push({\n        label: 'Z Axis',\n        layout: layout.zaxis,\n        property: 'z',\n        segment: this.mapping.z,\n      });\n    }\n  }\n\n  //-----------------------------------------------------------------------\n  // Manage Traces\n  //-----------------------------------------------------------------------\n\n  selectTrace(index: number) {\n    this.traces = this.ctrl.cfg.traces;\n    if (!this.traces || this.traces.length < 1) {\n      this.traces = this.ctrl.cfg.traces = [_.deepClone(PlotlyPanelCtrl.defaultTrace)];\n    }\n    if (index >= this.ctrl.cfg.traces.length) {\n      index = this.ctrl.cfg.traces.length - 1;\n    }\n    this.trace = this.ctrl.cfg.traces[index];\n    this.traceIndex = index;\n\n    _.defaults(this.trace, PlotlyPanelCtrl.defaultTrace);\n    if (!this.trace.name) {\n      this.trace.name = EditorHelper.createTraceName(index);\n    }\n\n    // The _defaults makes sure this is taken care of\n    this.symbol = this.ctrl.uiSegmentSrv.newSegment({\n      value: this.trace.settings.marker.symbol,\n    });\n\n    // Now set one for each key\n    this.mapping = {};\n    _.forEach(this.trace.mapping, (value, key) => {\n      this.updateSegMapping(value, key);\n    });\n\n    console.log('Editor Info', this);\n\n    this.onConfigChanged();\n    this.ctrl.refresh();\n  }\n\n  private updateSegMapping(value, key, updateTrace = false) {\n    if (REMOVE_KEY === value) {\n      this.mapping[key] = this.ctrl.uiSegmentSrv.newSegment({\n        value: 'Select Metric',\n        fake: true,\n      });\n      value = null; // will set this value later\n    } else if (value) {\n      const s = this.ctrl.seriesByKey.get(value);\n      const opts: any = {\n        value: value,\n        series: s,\n      };\n      if (!s) {\n        //  opts.fake = true;\n        opts.html = value + '  <i class=\"fa fa-exclamation-triangle\"></i>';\n      }\n      this.mapping[key] = this.ctrl.uiSegmentSrv.newSegment(opts);\n    } else {\n      this.mapping[key] = this.ctrl.uiSegmentSrv.newSegment({\n        value: 'Select Metric',\n        fake: true,\n      });\n    }\n\n    if (updateTrace) {\n      this.trace.mapping[key] = value;\n      console.log('SET', key, value, this.trace.mapping);\n    }\n  }\n\n  createTrace() {\n    let trace: any = {};\n    if (this.ctrl.cfg.traces.length > 0) {\n      trace = _.cloneDeep(this.ctrl.cfg.traces[this.ctrl.cfg.traces.length - 1]);\n    } else {\n      trace = _.deepClone(PlotlyPanelCtrl.defaultTrace);\n    }\n    trace.name = EditorHelper.createTraceName(this.ctrl.traces.length);\n    this.ctrl.cfg.traces.push(trace);\n    this.selectTrace(this.ctrl.cfg.traces.length - 1);\n  }\n\n  removeCurrentTrace() {\n    // TODO... better behavior\n    if (this.traces.length <= 1) {\n      console.error('Wont remove a single trace', this);\n      return;\n    }\n\n    for (let i = 0; i < this.traces.length; i++) {\n      if (this.trace === this.traces[i]) {\n        this.traces.splice(i, 1);\n        if (i >= this.traces.length) {\n          i = this.traces.length - 1;\n        }\n        this.ctrl.onConfigChanged();\n        this.ctrl._updateTraceData(true);\n        this.selectTrace(i);\n        this.ctrl.refresh();\n        return;\n      }\n    }\n\n    console.error('Could not find', this);\n  }\n\n  static createTraceName(idx: number) {\n    return 'Trace ' + (idx + 1);\n  }\n\n  //-----------------------------------------------------------------------\n  // SERIES\n  //-----------------------------------------------------------------------\n\n  getSeriesSegs(withRemove = false): Promise<any[]> {\n    return new Promise((resolve, reject) => {\n      const series: any[] = [];\n\n      if (withRemove) {\n        series.push(\n          this.ctrl.uiSegmentSrv.newSegment({\n            fake: true,\n            value: REMOVE_KEY,\n            series: null,\n          })\n        );\n      }\n      this.ctrl.series.forEach(s => {\n        series.push(\n          this.ctrl.uiSegmentSrv.newSegment({\n            value: s.name,\n            series: s,\n          })\n        );\n      });\n\n      //console.log('GET Segments:', withRemove, series);\n      //console.log('ALL Series:', this.ctrl.series);\n      resolve(series);\n    });\n  }\n\n  onAxisSeriesChanged(axis: AxisInfo) {\n    this.updateSegMapping(axis.segment.value, axis.property, true);\n    this.onConfigChanged();\n  }\n\n  getTextSegments(): any[] {\n    return [this.mapping.text];\n  }\n\n  onTextMetricChanged(sss: any) {\n    const seg = this.mapping.text;\n    this.updateSegMapping(seg.value, 'text', true);\n    this.onConfigChanged();\n  }\n\n  getColorSegments(): any[] {\n    if (this.trace.settings.color_option === 'ramp') {\n      return [this.mapping.color];\n    }\n    return [];\n  }\n\n  onColorChanged() {\n    const seg = this.mapping.color;\n    this.updateSegMapping(seg.value, 'color', true);\n    this.onConfigChanged();\n  }\n\n  //-----------------------------------------------------------------------\n  // SYMBOLS\n  //-----------------------------------------------------------------------\n\n  onSymbolChanged() {\n    this.trace.settings.marker.symbol = this.symbol.value;\n    this.onConfigChanged();\n  }\n\n  getSymbolSegs(): Promise<any[]> {\n    return new Promise((resolve, reject) => {\n      const txt = [\n        'circle',\n        'circle-open',\n        'circle-dot',\n        'circle-open-dot',\n        'square',\n        'square-open',\n        'square-dot',\n        'square-open-dot',\n        'diamond',\n        'diamond-open',\n        'diamond-dot',\n        'diamond-open-dot',\n        'cross',\n        'cross-open',\n        'cross-dot',\n        'cross-open-dot',\n        'x',\n        'x-open',\n        'x-dot',\n        'x-open-dot',\n        'triangle-up',\n        'triangle-up-open',\n        'triangle-up-dot',\n        'triangle-up-open-dot',\n        'triangle-down',\n        'triangle-down-open',\n        'triangle-down-dot',\n        'triangle-down-open-dot',\n        'triangle-left',\n        'triangle-left-open',\n        'triangle-left-dot',\n        'triangle-left-open-dot',\n        'triangle-right',\n        'triangle-right-open',\n        'triangle-right-dot',\n        'triangle-right-open-dot',\n        'triangle-ne',\n        'triangle-ne-open',\n        'triangle-ne-dot',\n        'triangle-ne-open-dot',\n        'triangle-se',\n        'triangle-se-open',\n        'triangle-se-dot',\n        'triangle-se-open-dot',\n        'triangle-sw',\n        'triangle-sw-open',\n        'triangle-sw-dot',\n        'triangle-sw-open-dot',\n        'triangle-nw',\n        'triangle-nw-open',\n        'triangle-nw-dot',\n        'triangle-nw-open-dot',\n        'pentagon',\n        'pentagon-open',\n        'pentagon-dot',\n        'pentagon-open-dot',\n        'hexagon',\n        'hexagon-open',\n        'hexagon-dot',\n        'hexagon-open-dot',\n        'hexagon2',\n        'hexagon2-open',\n        'hexagon2-dot',\n        'hexagon2-open-dot',\n        'octagon',\n        'octagon-open',\n        'octagon-dot',\n        'octagon-open-dot',\n        'star',\n        'star-open',\n        'star-dot',\n        'star-open-dot',\n        'hexagram',\n        'hexagram-open',\n        'hexagram-dot',\n        'hexagram-open-dot',\n        'star-triangle-up',\n        'star-triangle-up-open',\n        'star-triangle-up-dot',\n        'star-triangle-up-open-dot',\n        'star-triangle-down',\n        'star-triangle-down-open',\n        'star-triangle-down-dot',\n        'star-triangle-down-open-dot',\n        'star-square',\n        'star-square-open',\n        'star-square-dot',\n        'star-square-open-dot',\n        'star-diamond',\n        'star-diamond-open',\n        'star-diamond-dot',\n        'star-diamond-open-dot',\n        'diamond-tall',\n        'diamond-tall-open',\n        'diamond-tall-dot',\n        'diamond-tall-open-dot',\n        'diamond-wide',\n        'diamond-wide-open',\n        'diamond-wide-dot',\n        'diamond-wide-open-dot',\n        'hourglass',\n        'hourglass-open',\n        'bowtie',\n        'bowtie-open',\n        'circle-cross',\n        'circle-cross-open',\n        'circle-x',\n        'circle-x-open',\n        'square-cross',\n        'square-cross-open',\n        'square-x',\n        'square-x-open',\n        'diamond-cross',\n        'diamond-cross-open',\n        'diamond-x',\n        'diamond-x-open',\n        'cross-thin',\n        'cross-thin-open',\n        'x-thin',\n        'x-thin-open',\n        'asterisk',\n        'asterisk-open',\n        'hash',\n        'hash-open',\n        'hash-dot',\n        'hash-open-dot',\n        'y-up',\n        'y-up-open',\n        'y-down',\n        'y-down-open',\n        'y-left',\n        'y-left-open',\n        'y-right',\n        'y-right-open',\n        'line-ew',\n        'line-ew-open',\n        'line-ns',\n        'line-ns-open',\n        'line-ne',\n        'line-ne-open',\n        'line-nw',\n        'line-nw-open',\n      ];\n\n      const segs: any[] = [];\n      _.forEach(txt, val => {\n        segs.push(this.ctrl.uiSegmentSrv.newSegment(val));\n      });\n      resolve(segs);\n    });\n  }\n}\n","import $script from 'scriptjs';\n\nlet loaded: any; // Plotly Library\nlet isFull = false;\nlet wasCDN = false;\n\nexport function loadPlotly(cfg: any): Promise<any> {\n  if (loaded) {\n    console.log('using already loaded value');\n    return Promise.resolve(loaded);\n  }\n\n  const needsFull = cfg.settings.type !== 'scatter';\n  let url = 'public/plugins/natel-plotly-panel/lib/plotly-cartesian.min.js';\n  if (cfg.loadFromCDN) {\n    url = needsFull\n      ? 'https://cdn.plot.ly/plotly-latest.min.js'\n      : 'https://cdn.plot.ly/plotly-cartesian-latest.min.js';\n  } else if (needsFull) {\n    url = 'public/plugins/natel-plotly-panel/lib/plotly.min.js';\n  }\n  return new Promise((resolve, reject) => {\n    $script(url, resolve);\n  }).then(res => {\n    isFull = needsFull;\n    wasCDN = cfg.loadFromCDN;\n    loaded = window['Plotly'];\n    return loaded;\n  });\n}\n\nexport function loadIfNecessary(cfg: any): Promise<any> {\n  if (!loaded) {\n    return loadPlotly(cfg);\n  }\n\n  if (wasCDN !== cfg.loadFromCDN) {\n    console.log('Use CDN', cfg.loadFromCDN);\n    loaded = null;\n    return loadPlotly(cfg);\n  }\n\n  const needsFull = cfg.settings.type !== 'scatter';\n  if (needsFull && !isFull) {\n    console.log('Switching to the full plotly library');\n    loaded = null;\n    return loadPlotly(cfg);\n  }\n\n  // No changes\n  return Promise.resolve(null);\n}\n","/*!\n  * $script.js JS loader & dependency manager\n  * https://github.com/ded/script.js\n  * (c) Dustin Diaz 2014 | License MIT\n  */\n\n(function (name, definition) {\n  if (typeof module != 'undefined' && module.exports) module.exports = definition()\n  else if (typeof define == 'function' && define.amd) define(definition)\n  else this[name] = definition()\n})('$script', function () {\n  var doc = document\n    , head = doc.getElementsByTagName('head')[0]\n    , s = 'string'\n    , f = false\n    , push = 'push'\n    , readyState = 'readyState'\n    , onreadystatechange = 'onreadystatechange'\n    , list = {}\n    , ids = {}\n    , delay = {}\n    , scripts = {}\n    , scriptpath\n    , urlArgs\n\n  function every(ar, fn) {\n    for (var i = 0, j = ar.length; i < j; ++i) if (!fn(ar[i])) return f\n    return 1\n  }\n  function each(ar, fn) {\n    every(ar, function (el) {\n      fn(el)\n      return 1\n    })\n  }\n\n  function $script(paths, idOrDone, optDone) {\n    paths = paths[push] ? paths : [paths]\n    var idOrDoneIsDone = idOrDone && idOrDone.call\n      , done = idOrDoneIsDone ? idOrDone : optDone\n      , id = idOrDoneIsDone ? paths.join('') : idOrDone\n      , queue = paths.length\n    function loopFn(item) {\n      return item.call ? item() : list[item]\n    }\n    function callback() {\n      if (!--queue) {\n        list[id] = 1\n        done && done()\n        for (var dset in delay) {\n          every(dset.split('|'), loopFn) && !each(delay[dset], loopFn) && (delay[dset] = [])\n        }\n      }\n    }\n    setTimeout(function () {\n      each(paths, function loading(path, force) {\n        if (path === null) return callback()\n        \n        if (!force && !/^https?:\\/\\//.test(path) && scriptpath) {\n          path = (path.indexOf('.js') === -1) ? scriptpath + path + '.js' : scriptpath + path;\n        }\n        \n        if (scripts[path]) {\n          if (id) ids[id] = 1\n          return (scripts[path] == 2) ? callback() : setTimeout(function () { loading(path, true) }, 0)\n        }\n\n        scripts[path] = 1\n        if (id) ids[id] = 1\n        create(path, callback)\n      })\n    }, 0)\n    return $script\n  }\n\n  function create(path, fn) {\n    var el = doc.createElement('script'), loaded\n    el.onload = el.onerror = el[onreadystatechange] = function () {\n      if ((el[readyState] && !(/^c|loade/.test(el[readyState]))) || loaded) return;\n      el.onload = el[onreadystatechange] = null\n      loaded = 1\n      scripts[path] = 2\n      fn()\n    }\n    el.async = 1\n    el.src = urlArgs ? path + (path.indexOf('?') === -1 ? '?' : '&') + urlArgs : path;\n    head.insertBefore(el, head.lastChild)\n  }\n\n  $script.get = create\n\n  $script.order = function (scripts, id, done) {\n    (function callback(s) {\n      s = scripts.shift()\n      !scripts.length ? $script(s, id, done) : $script(s, callback)\n    }())\n  }\n\n  $script.path = function (p) {\n    scriptpath = p\n  }\n  $script.urlArgs = function (str) {\n    urlArgs = str;\n  }\n  $script.ready = function (deps, ready, req) {\n    deps = deps[push] ? deps : [deps]\n    var missing = [];\n    !each(deps, function (dep) {\n      list[dep] || missing[push](dep);\n    }) && every(deps, function (dep) {return list[dep]}) ?\n      ready() : !function (key) {\n      delay[key] = delay[key] || []\n      delay[key][push](ready)\n      req && req(missing)\n    }(deps.join('|'))\n    return $script\n  }\n\n  $script.done = function (idOrDone) {\n    $script([null], idOrDone)\n  }\n\n  return $script\n});\n","import {Shape, Data} from 'plotly.js';\n\nexport class AnnoInfo {\n  trace: Data;\n  shapes: Shape[];\n\n  constructor() {\n    this.clear();\n  }\n\n  clear() {\n    this.shapes = [];\n    this.trace = {\n      mode: 'markers',\n      type: 'scatter',\n      hoverinfo: 'x+text',\n      x: [],\n      y: [],\n      text: [],\n      yaxis: 'y2',\n      marker: {\n        size: 15,\n        symbol: 'triangle-up',\n        color: [],\n      },\n    };\n  }\n\n  update(results: any): boolean {\n    if (!results || !results.annotations) {\n      this.clear();\n      return false;\n    }\n\n    const x: number[] = [];\n    const y: number[] = [];\n    const text: string[] = [];\n    const color: string[] = [];\n\n    this.shapes = results.annotations.map(a => {\n      x.push(a.time);\n      y.push(0);\n      text.push(a.text);\n      color.push(a.annotation.iconColor);\n\n      return {\n        type: 'line', // rect\n        xref: 'x',\n        yref: 'paper',\n        x0: a.time,\n        y0: 0,\n        x1: a.time,\n        y1: 1,\n\n        visible: true,\n        layer: 'above',\n\n        fillcolor: a.annotation.iconColor,\n        opacity: 0.8,\n        line: {\n          color: a.annotation.iconColor,\n          width: 1,\n          dash: 'dash',\n        },\n      } as Shape;\n    });\n\n    // Overwrite it with new points\n    this.trace = {...this.trace, x, y, text} as any;\n    (this.trace as any).marker.color = color;\n    return x.length > 0;\n  }\n}\n"],"sourceRoot":""}